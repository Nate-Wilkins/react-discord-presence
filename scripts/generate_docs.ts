import { exec } from 'child_process';
import { createHash } from 'node:crypto';
import fs from 'fs';
import Mustache from 'mustache';
import path from 'path';

/*
 * Load JSON file.
 */
const loadJsonFileSync = (filePath: string) => {
  return JSON.parse(fs.readFileSync(filePath, 'utf-8'));
};

/*
 * Get used local dependency info for a particular package.
 */
const getLocalDependency = async ({
  name,
}: {
  name: string;
}): Promise<string> => {
  const { stdout, stderr } = await exec.__promisify__('npm list --depth=0');
  if (stderr) {
    throw new Error(stderr);
  }

  // Pull out dependency version.
  const regexDependency = new RegExp(`/\\s+(${name}.+)$`, '');
  const match = regexDependency.exec(stdout);
  if (!match) {
    throw new Error(`Unable to find dependency '${name}' in local packages.`);
  }
  const matchPackage = match[1];
  console.info(
    `[build:generate_docs:getLocalDependency]: Found '${matchPackage}'.`,
  );

  return matchPackage;
};

/*
 * Get Unpkg package information for provided packages.
 *
 * Includes:
 * - Unpkg URL.
 * - Unpkg hash.
 */
const getUnpkgPackages = async ({
  packages,
  cdnFileLookup,
  hashType,
}: {
  packages: Record<string, string>;
  cdnFileLookup: Record<string, null | string>;
  hashType: string;
}): Promise<{
  [key: string]: {
    versionRange: string;
    unpkg: { name: string; cdn: string; hash: string };
  };
}> => {
  const packageKeys = Object.keys(packages);

  return (
    await Promise.all(
      packageKeys.map(key => {
        return async () => {
          const pkgVersion = await getLocalDependency({ name: key });
          const unpkgDistFile = cdnFileLookup[key];
          if (!unpkgDistFile) {
            throw new Error(`No Unpkg distributable file found for '${key}'.`);
          }

          const unpkgCdnDistFile = `https://unpkg.com/${pkgVersion}/${unpkgDistFile}`;
          const unpkgCdnDistFileResponse = await fetch(unpkgCdnDistFile, {});
          const unpkgCdnDistFileContent = await unpkgCdnDistFileResponse.text();

          return {
            versionRange: packages[key],
            unpkg: {
              name: key,
              cdn: unpkgCdnDistFile,
              hash: createHash(hashType)
                .update(unpkgCdnDistFileContent)
                .digest('hex'),
            },
          };
        };
      }),
    )
  ).reduce((aggregate, dependency) => {
    return { ...aggregate, [dependency.name]: dependency };
  }, {});
};

// Configuration.
const documentsDirectory = `../docs/`;
const documentTemplateFileNames = ['Customization.template.md'];
const documentOutputHeaderAutogenerated = `
[//]: # "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
[//]: # "!!!!!!                                     !!!!!!"
[//]: # "!!!!!!      >>>>> WARNING <<<<<            !!!!!!"
[//]: # "!!!!!!                                     !!!!!!"
[//]: # "!!!!!! This file is autogenerated.         !!!!!!"
[//]: # "!!!!!!                                     !!!!!!"
[//]: # "!!!!!!      >>>>> WARNING <<<<<            !!!!!!"
[//]: # "!!!!!!                                     !!!!!!"
[//]: # "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
`;
// sha256-tM7OyCTTeRmKCxduIW+XWZ1NckTmAvDsLy6+FD+x4gw=
const documentPackagePeerDependencyHash = 'sha256';
const documentPackagePeerDependencyUnpkgCdnFile = {
  react: '/umd/react.production.min.js',
};

// Main.
try {
  console.info('[build:generate_docs] Build documents.');

  // Get package information.
  console.info('[build:generate_docs] Get package information.');
  const pkg = loadJsonFileSync('package.json');
  console.info('[build:generate_docs] Package Information:');
  console.info({ package: pkg });

  // Generate documents.
  for (const documentTemplateFileName of documentTemplateFileNames) {
    // Load document template.
    console.info(
      `[build:generate_docs:${documentTemplateFileName}] Load template.`,
    );
    const documentTemplate = fs.readFileSync(
      path.join(__dirname, documentsDirectory, documentTemplateFileName),
      'utf-8',
    );
    // Render document.
    const documentOutput = Mustache.render(documentTemplate, {
      name: pkg.name,
      peerDependencies: await getUnpkgPackages({
        packages: pkg.peerDependencies,
        hashType: documentPackagePeerDependencyHash,
        cdnFileLookup: documentPackagePeerDependencyUnpkgCdnFile,
      }),
      pkg,
    });
    // Write document outpput.
    fs.writeFileSync(
      path.join(
        __dirname,
        documentsDirectory,
        documentTemplateFileName.replace('.mustache', ''),
      ),
      `${documentOutputHeaderAutogenerated}${documentOutput}`,
      'utf-8',
    );
  }

  process.exit(0);
} catch (e) {
  console.error(e ? e.message : e);
  process.exit(2);
}
